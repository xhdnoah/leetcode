package main

// Input: "25525511135" Output: ["255.255.11.135", "255.255.111.35"]
// DFS 深度搜索；IP 规则：0 开头和超过 255 的数字都是非法的
func restoreIPAddress(s string) (res []string) {
	// k: 分隔符 . 的个数; i: 遍历 s 的索引; val: IP 段的值; prev: 之前构造的 IP 地址（部分
	var construct func(k, i, val int, prev []byte)
	construct = func(k, i, val int, prev []byte) {
		// 单个 IP 段增长或 IP 段数目超过上限则退出递归
		if k > 3 || val >= 256 {
			return
		}
		if i == len(s) {
			if k == 3 { // 索引走到头且分隔符到头
				res = append(res, string(prev))
			}
			return
		}

		val = int(s[i]-'0') + val*10            // s[i] 为 byte(uint8) 类型，值为 ‘x’ 的 ascii 码，通过与 ‘0’ 字节的差值得出真实的字符串中的数字
		prev = append(prev, s[i])               // 第一个递归向 . 后新增数字，第二个递归向当前 IP 地址最后新增
		if i+1 < len(s) && val < 256 && k < 3 { // 一开始先尽可能新增 IP 片段 2.5.5.2
			construct(k+1, i+1, 0, append(prev, '.'))
		}
		if val != 0 || i == len(s)-1 { // 新增 val
			construct(k, i+1, val, prev)
		}
	}

	construct(0, 0, 0, make([]byte, 0, 32))
	return
}

func main() {
	restoreIPAddress("25525511135")
}

// k, i, val, prev
// 递归树 1 从 L25 入口进入
// 0 0 0
// 1 1 0 2.
// 2 2 0 2.5. 分支 1-1 分出前的交叉点 A, 在此之前只执行了第一个 construct
// 3 3 0 2.5.5. k 达到 3 分支 1-1 从 L28 入口再次展开
// 3 4 2 2.5.5.2
// 3 5 25 2.5.5.25
// 3 6 255 2.5.5.255
// 3 7 2551 2.5.5.2551
// 此时 val > 256 分支 1-1 从 L13 出口退回到交叉点 A
// 从交叉点 A 开始顺序执行第二个 construct(k, i+1,..) 展开 1-2
// 2 3 5 2.5.5 // 交叉点 B, 之后 k 达到 3, 树从 L28 分出
// 3 4 0 2.5.52.
// 3 5 5 2.5.52.5
// 3 6 55 2.5.52.55
// 3 7 551 2.5.52.551
// 退回到交叉点 B
// 2 4 52 2.5.52
// 2 5 525 2.5.525 此处 return 已无剩余代码执行
// 退回到 A 前一个调用栈，顺序执行第二个 construct
// 1 2 5 2.5
// 2 3 0 2.55. // 分叉点 C
// 3 4 0 2.55.2.
// 3 5 5 2.55.2.5
// 3 6 55 2.55.2.55
// 3 7 551 2.55.2.551
// 退回到 C
// 2 4 2 2.55.2
// 3 5 0 2.55.25.
// 3 6 5 2.55.25.5
// 3 7 51 2.55.25.51
// 3 8 511 2.55.25.511
// ... 共两个 construct:
// 甲执行条件为 k val 在边界内，其目的是增长 k, 传入 val 0
// 乙执行条件只需索引还没扫完字符串 S, 其目的是使用后续 s 增长 val
// 在甲的探索失败后会退回到上一个还没有执行乙的节点并执行之，收缩 k 增长 val
// 而在恢复增长了一次 val 只要 k < 3 后续函数还是会优先增长 k 直到 == 3
// 中途会多次一直退回到 k 为 0 的情况，如：
// 0 1 2 2
// 0 2 25 25
// 0 3 255 255
// 0 4 2552 2552
// 总结，其实不用太关心递归细节，只要明确两个方向，增长 k / val 及其入口条件，最终总会找到正确的 IP 地址
